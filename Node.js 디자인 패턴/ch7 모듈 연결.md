추상화를 사용하지 않는 것이 JS 에 행사 코드를 줄어들게 하는 가장 큰 이유로 보인다. 덕분에 많은 디자인 패턴이 단순명료해진다.

### 모듈과 의존성
모듈은 캐싱되기 때문에 같은 모듈을 같은 패키지 안의 다른 소스에서 require 할 경우 같은 인스턴스가 전달된다.
하지만 npm 으로 사용되는 모듈의 경우 패키지마다 다른 모듈로 인식하기 때문에 서로 다른 인스턴스가 전달 받게 된다.
앞의 동작은 싱글톤 패턴이지만 두번째 경우는 그렇지 않아 혼동을 일으킨다.

### 모듈 연결 패턴
상태 저장 인스턴스의 연결 방법 중심으로 분석

##### 하드코딩된 종속성
단위 테스트 어려움, 가장 하위 모듈을 테스트 할때는 문제가 나타나지 않는다.
그 다음 상위 모듈로 갈수록 테스트는 어려워진다.
수정 사항이 발생했을때 해당 모듈에 대한 단위 테스트 코드만 수정하는 것이 아니라, 
다른 모든 테스트 코드를 수정해야 할 필요가 있다면, 이와같이 모듈간의 종속성이 강하게 존재한다는 증거다.

##### 의존성 주입(DI)
의존 관계의 연결 책임을 상위 모듈로 옮기는 방법,
상위 수준의 컴포넌트가 하위 수준의 컴포넌트보다 재상용성이 낮고 계층이 올라갈수록 컴포넌트가 구체화되기 때문이다.
하지만 연결해야 할 모듈 수가 많을때 관리가 어려워짐, 종속성 소유권을 분할 관리해야 한다.

* 다양한 유형의 DI
  * 생성자 인젝션: new 를 사용하여 객체를 명시적으로 생성하고 의존성을 입력한다.
  * 속성 인젝션: new 를 사용하여 객체를 생성한뒤 동적으로 속성을 할당한다.

##### 서비스 로케이터

##### 의존성 주입 컨테이너

계층이 깊어질 수록 최상위 모듈과 최하위 모듈 사이에 존재하는 모든 모듈 사이에 연결 통로, 의존성 주입 통로가 필요하다.
React 의 경우, redux 를 사용하여 서로간의 신호전달을 별도의 모듈을 통해 진행한다. DI 컨테이너의 동작과 유사해 보인다.

### 연결(Wiring)을 위한 플러그인
* 참조하는 모듈의 경로가 명확하지 않으면 에러가 발생한다. 하지만 패키지로 주요 모듈을 분리하면 경로가 고정되고 에러가 발생하지 않는다.
* 다른 프로젝트에서 재사용이 쉬워진다.

##### 플러그인 제어 vs 어플리케이션 제어 확장(IoC - Inversion of Control)
* 플러그인 제어 
  * 어플리케이션의 변경이 발생할때마다 플러그인을 수정해야 한다.
  * 어플리케이션의 내부 서비스 전체(?)를 플러그인과 공유 &rarr; 보안문제?
* 어플리케이션 제어
  * 어플리케이션에 플러그인을 더하기 위한 인프라가 필요
  * 플러그인이 어플리케이션의 일부 서비스만 사용

##### 로그아웃 플러그인 구현하기
* 하드코딩된 의존성
  * impersonating(부모 모듈 가장) 패턴 `const parentRequire = module.parent.require`
  * 장점: 최소한의 인프라로 메인 어플리케이션의 모든 서비스에 액세스
  * 단점: 사용 서비스의 위치와 강한 결합성
* 종속성 주입(DI)
  * 과도한 확장에 대하여 정보 숨기기나 보호 기능이 향상
  * 어플리케이션이 플러그인의 필요한 종속성을 다 알아야 하는 단점
* 서비스 로케이터
  * 어플리케이션의 모든 컴포넌트를 플러그인에 노출
  * 어플리케이션이 플러그인에 필요한 종속성을 미리 알필요가 없다. 플러그인에서 자체적으로 처리
* DI 컨테이너
  * 자동으로 DI 동작하기 때문에 어플리케이션에서 필요한 종속성을 찾지 않아도 됨
  * 플러그인에서 어플리케이션의 모든 서비스의 접근이 가능함, 하지만 DI 에서 정보공개 제한을 설정하면 은닉이 가능함
  * 결론적으로 캡슐화도 되면서 자동적으로 종속성 주입도 
