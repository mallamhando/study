### 비동기적으로 초기화되는 require 모듈
* require 뿐만 아니라 다른 비동기적 기능에 적용 가능
* 비동기적 초기화가 완료되기전에 요청되는 입력을 큐에 저장하고, 초기화가 완료되면 큐에 팬딩된 작업들을 실행

### 비동기 배치 및 캐싱
##### 비동기 요청 일괄 처리
* 같은 요청을 큐에 저장한뒤 한번에 전달

##### 비동기 요청 캐싱
* 캐싱은 새로운 것이 아니지만, 일괄 처리와 결합하면 어렵다.
* 캐싱을 하는것과 동시에 캐싱데이터를 적당한 시점에 삭제하는것도 중요하다.
* 데이터가 갱신되어 캐싱데이터가 업데이트되는 시점도 중요하다.
* 인스턴스가 분산되어 있을 경우 캐싱데이터를 공유하기 위해 redis 등을 사용할 수 있다.

##### Promise 일괄 처리
* Promise 에는 큐 저장 후 일괄 처리 기능이 내장되어 있다.
* Promise 를 then 으로 호출하는 모든 인스턴스는 결과가 반환될때 일괄적으로 호출된다.
* 큐 저장 일괄 처리는 Promise 로 대체되어 사용되어야 한다.

### CPU 바운딩 작업 
* 싱글 스레드 동작의 단점을 보안하기 위한 방법이 필요하다.

##### setImmediate 를 이용한 인터리빙(Interleaving)
* CPU 자원을 독점 사용하는 로직을 setImmediate 로 분리하여 동작시킨다.
* setImmediate 사이에 다른 이벤트 I/O 처리가 가능해진다.
* 적절한 setImmediate 분리가 쉽지 않다. 비지니스 로직이 명확해지지 않는다.

##### 멀티 프로세스 사용
* 멀티 프로세스는 싱글 스레드의 단점을 극복하는데 도움이 되겠지만, 각 동작에 멀티 프로세스에 대한 행사코드가 추가되게 된다.
* 멀티 프로세스를 사용하는 것보다 redis 같은 공용 메모리 공간을 이용하여 관찰자 패턴을 사용하는 것이 코드를 줄이는 방법이 되지 않을까?
* 웹 프론트엔드에서는 근본적으로 redis 를 사용할수가 없다. 따라서 web worker 같은 신규 기능을 사용할 수 밖에 없다.
* 스레드 기반의 webworker 는 freezing 과 crashing 문제에 약하다. 멀티 프로세스는 스레드보다 더 큰 유연성과 격리 수준을 제공한다.
