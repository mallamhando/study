### 적응자(Adapter)
### 가교(Bridge)
### 복합체(COMPOSITE)
클래스 상속보다 합성이 더 나은 방법이다. 복합 패턴을 합성 방법과 헷갈려하고 있었는데 설명된 복합 패턴은 전혀 다른 구조였다. 검색을 해보니 나만 그런게 아닌가보다. 영어 철자부터 유사하다. COMPOSITE PATTERN vs COMPOSITION. 뜻은 Java 와 Javascript 만큼 다르다.

### 장식자(Decorator)
개념은 이해하지만 구현을 이해하기는 어렵다. GOF 의 모든 설명이 그렇다. C++ 이라는 언어적 한계 때문이다. 깊이를 놓 아쉽지만 앞으로 나아가기 위해서는 그냥 지나가야 할때도 있다.

### 퍼사드(Facade)
객체지향을 떠나 기본적인 프로그래밍 구조다. 이 용어를 모르더라도, 이 구조를 고민하지 않고 프로그램을 만드는것은 문제이다. 무엇보다 이 기본을 전혀 고려하지 않던 거대 프로젝트 팀에 대한 기억이 너무 강렬하다. 그 많은 똑똑한 인재들은 구조를 효율화하고 성능을 향상시키는 것에 관심이 없었다. 그들 대부분의 관심은 오로지 '무사안일' 이었다. 공포를 벗어나기 위해 사는것과 즐거움을 얻기 위해 사는 방식은 근본적으로 다르다.

### 플라이급(Flyweight)
##### 원리
많이 사용하는 객체를 본질/부가적 요소로 구분한다. 본질은 pool 형태로 공유하고, 부가적인 요소만 따로 저장한다. 공유하는 본질부분의 저장 공간과 반복 코드를 줄일 수 있다.

##### 감상
객체 대부분의 기능을 static 함수로 만들고 부가적인 요소만 작게 만든다면 함수 합성으로 기능 확장이 쉬어지고, 부수효과에 영향을 받는 상태값 저장 부분을 구분할수 있어 디버깅이 쉬어진다. 그 범위를 넓혀 static 함수들을 별도의 static 객체로 분리한다면 둘 사이의 구분이 더 쉬어지고, static 객체가 다수로 참조될때 그 저장 공간을 절약할수 있다.

단점으로 코드가 약간 증가하고 런타임 연결에 대한 소요시간이 추가적으로 발생한다. 절차적 코드가 객체지향으로 변경될때 어느정도 발생하는 현상으로 보인다. 그렇기 때문에 알고리즘 복잡도 계산과 마찬가지로 개수가 많아지게 될수록, 기능의 복잡도가 커질 수록 그 효율은 증가하게 된다.

### 프록시(Proxy)
