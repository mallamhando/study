### 적응자(Adapter)
### 가교(Bridge)
### 복합체(COMPOSITE)
클래스 상속보다 합성이 더 나은 방법이다. 복합 패턴을 합성 방법과 헷갈려하고 있었는데 설명된 복합 패턴은 전혀 다른 구조였다. 검색을 해보니 나만 그런게 아닌가보다. 영어 철자부터 유사하다. COMPOSITE PATTERN vs COMPOSITION. 뜻은 Java 와 Javascript 만큼 다르다.

### 장식자(Decorator)
개념은 이해하지만 구현을 이해하기는 어렵다. GOF 의 모든 설명이 그렇다. C++ 이라는 언어적 한계 때문이다. 깊이를 놓 아쉽지만 앞으로 나아가기 위해서는 그냥 지나가야 할때도 있다.

### 퍼사드(Facade)
객체지향을 떠나 기본적인 프로그래밍 구조다. 이 용어를 모르더라도, 이 구조를 고민하지 않고 프로그램을 만드는것은 문제이다. 무엇보다 이 기본을 전혀 고려하지 않던 거대 프로젝트 팀에 대한 기억이 너무 강렬하다. 그 많은 똑똑한 인재들은 구조를 효율화하고 성능을 향상시키는 것에 관심이 없었다. 그들 대부분의 관심은 오로지 '무사안일' 이었다. 공포를 벗어나기 위해 사는것과 즐거움을 얻기 위해 사는 방식은 근본적으로 다르다.

### 플라이급(Flyweight)
##### 원리
많이 사용하는 객체를 본질/부가적 요소로 구분한다. 본질은 pool 형태로 공유하고, 부가적인 요소만 따로 저장한다. 공유하는 본질부분의 저장 공간과 반복 코드를 줄일 수 있다.

##### 감상
객체 대부분의 기능을 static 함수로 만들고 부가적인 요소만 작게 만든다면 함수 합성으로 기능 확장이 쉬어지고, 부수효과에 영향을 받는 상태값 저장 부분을 구분할수 있어 디버깅이 쉬어진다. 그 범위를 넓혀 static 함수들을 별도의 static 객체로 분리한다면 둘 사이의 구분이 더 쉬어지고, static 객체가 다수로 참조될때 그 저장 공간을 절약할수 있다.

단점으로 코드가 약간 증가하고 런타임 연결에 대한 소요시간이 추가적으로 발생한다. 절차적 코드가 객체지향으로 변경될때 어느정도 발생하는 현상으로 보인다. 그렇기 때문에 알고리즘 복잡도 계산과 마찬가지로 개수가 많아지게 될수록, 기능의 복잡도가 커질 수록 그 효율은 증가하게 된다.

### 프록시(Proxy)
적응자는 다른 인터페이스를 제공하지만 프록시는 제어 대상 객체와 동일한 인터페이스를 유지한다.

장식자는 기능을 더하지만 프로시는 오히려 제한하거나 감시한다

JS 디자인 패턴 책에서 설명한 프록시와 달라 복합체 패턴처럼 용어를 내가 헷갈리고 있는것은 아닐까 생각했다. 하지만 GOF 의 프록시 패턴 설명이 가상 프록시 패턴 부터 시작되었기 때문이다. 그만큼 프록시의 쓰임은 체인지업의 다양함처럼 다양하다

적응자등 이런 구조 패턴이 비효율적으로 보일때도 있다. 필요한 기능을 바로 부르는것이 아니라 중간 단계를 거쳐 인스턴스를 호출하기 때문이다. 잘못된 추상화의 예에서도 단순 호출 기능만 있는 클래스에 대해서 경계하고 있다. CPU 의 작업양도 중간 단계 과정의 추가로 인해 확실히 증가한다.

하지만 도메인을 분리하고, 객체들의 유연성을 높이기 위해서는 이런 분리작업이 필요하다. 기능이 완성되기 전까지는 이런 중간 단계가 필요한지 아닌지 알수가 없다.

각 관심사에 집중하여 모듈을 완성하고 상호 연결하기 위해서는 중간 매개체가 편리하다.

동작의 효율화는 상호 연결과정의 최적화 작업을 통해서도 가능하며, 더 명확하게 상호 연결 동작을 구분할수 있는 장점도 발생한다.

주요 기능이 2 개 이상인 간단한 F/W 에서도 중간 단계의 구조체가 편리하게 사용된다.
