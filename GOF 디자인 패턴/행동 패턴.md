### 책임 연쇄 패턴
직전에 확인한 프록시 패턴과 무엇이 다를까 생각했는데, 책에서는 결론적으로 복합체 패턴과 같이 사용된다고 설명한다.

기능이 쉽게 병렬화 될 수 있는 F/W 단계 에서는 직접적인 예가 떠오르지 않는다.

복합체 패턴과 동일하게 리눅스 커널 드라이버 구조에서는 많이 쓰였던것 같다.

C 언어의 특성상 클래스 상속이 아닌 객체 합성을 통한 상속만을 지원하기 때문에 복합체 패턴과 책임 연쇄 패턴의 사용은 당연해 보인다.

### 명령 패턴
자바스크립트에서는 callback 패턴이 기본이기 때문에 receiver 를 등록하는 명령 패턴이 일상적이라고 볼 수 있다.

다른 패턴들과 점점 더 구분이 어려워 진다. 취소, 재실행 기능을 말하고 있지만 패턴의 본질은 수신 객체와 명령 인터페이스 사이의 **연결**로 보인다.

다만 어떤 상황을 해결하기 위한 주요 구조와 해답으로 어떤 패턴을 말하는것은 필요하다.

실제 구현이 다양한 패턴들의 조합으로 이루어진다고 해도, 문제를 효율적으로 만들기 위한 리팩토링 과정에서 특정 패턴을 언급하는것은 편리하다.

### 해석자 패턴
자바스크립트에서는 못 본것 같다.

기본 parser 가 너무 잘되어 있기 때문으로 보인다.

이 책에서 처음 봤음

매크로 해석용이 아니더라도 비슷한 종류의 다양하고 작은 기능들을 조합하는 상황이라면

함수를 미세하게 쪼개고 상위 명령에 맞게 조합하는 기능으로 적합해 보인다.

함수형 프로그래밍 개념과 비슷해 보인다.

### 중재자 패턴
MFPlayer FPGA 설계를 할때 유용하게 쓰였다. Spi 인터페이스와 picker 를 완전히 분리하고 둘사이의 연결을 위한 별도의 모듈을 사용했다

적응자, 가교 등의 패턴들의 차이는 미세하게 느껴진다. 그리고 그 차이를 구분하는것은 어쩌면 불필요한 것일 수도 있다.

중요한 것은 객체지향의 특성을 잘 활용하여 견교하면서도 유연한 기능이 넘치는 프로그램을 만들어 내는 것이다.

### 메멘토 패턴
재실행, 취소 등 변화에 대한 기록을 남기는 기능이 필요할때, 원본의 확장은 최소화 하면서 동시에 원본의 캡슐화를 유지하는 패턴이다.

변화 내용을 별도의 클래스를 통해 저장하면서 권한을 원본에게만 주어지도록 하여 이러한 요구를 모두 만족시킬 수 있다.

### 옵져버 패턴
