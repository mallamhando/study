### 책임 연쇄 패턴
직전에 확인한 프록시 패턴과 무엇이 다를까 생각했는데, 책에서는 결론적으로 복합체 패턴과 같이 사용된다고 설명한다.

기능이 쉽게 병렬화 될 수 있는 F/W 단계 에서는 직접적인 예가 떠오르지 않는다.

복합체 패턴과 동일하게 리눅스 커널 드라이버 구조에서는 많이 쓰였던것 같다.

C 언어의 특성상 클래스 상속이 아닌 객체 합성을 통한 상속만을 지원하기 때문에 복합체 패턴과 책임 연쇄 패턴의 사용은 당연해 보인다.

### 명령 패턴
자바스크립트에서는 callback 패턴이 기본이기 때문에 receiver 를 등록하는 명령 패턴이 일상적이라고 볼 수 있다.

다른 패턴들과 점점 더 구분이 어려워 진다. 취소, 재실행 기능을 말하고 있지만 패턴의 본질은 수신 객체와 명령 인터페이스 사이의 **연결**로 보인다.

다만 어떤 상황을 해결하기 위한 주요 구조와 해답으로 어떤 패턴을 말하는것은 필요하다.

실제 구현이 다양한 패턴들의 조합으로 이루어진다고 해도, 문제를 효율적으로 만들기 위한 리팩토링 과정에서 특정 패턴을 언급하는것은 편리하다.

### 해석자 패턴
자바스크립트에서는 못 본것 같다.

기본 parser 가 너무 잘되어 있기 때문으로 보인다.

이 책에서 처음 봤음

매크로 해석용이 아니더라도 비슷한 종류의 다양하고 작은 기능들을 조합하는 상황이라면

함수를 미세하게 쪼개고 상위 명령에 맞게 조합하는 기능으로 적합해 보인다.

함수형 프로그래밍 개념과 비슷해 보인다.

### 중재자 패턴
MFPlayer FPGA 설계를 할때 유용하게 쓰였다. Spi 인터페이스와 picker 를 완전히 분리하고 둘사이의 연결을 위한 별도의 모듈을 사용했다

적응자, 가교 등의 패턴들의 차이는 미세하게 느껴진다. 그리고 그 차이를 구분하는것은 어쩌면 불필요한 것일 수도 있다.

중요한 것은 객체지향의 특성을 잘 활용하여 견교하면서도 유연한 기능이 넘치는 프로그램을 만들어 내는 것이다.

### 메멘토 패턴
재실행, 취소 등 변화에 대한 기록을 남기는 기능이 필요할때, 원본의 확장은 최소화 하면서 동시에 원본의 캡슐화를 유지하는 패턴이다.

변화 내용을 별도의 클래스를 통해 저장하면서 권한을 원본에게만 주어지도록 하여 이러한 요구를 모두 만족시킬 수 있다.

### 옵져버 패턴
가장 많이 사용하고 있는 패턴이지만 패턴으로 만들어진 코드는 아직 만들지 않음, 주의해야 할점은 상호 옵져버 상황에 되면서 순환참조가 발생하는 경우를 피해야 하는것이다.

모듈과 모듈 사이에 어쩔 수 없는 순환참조가 발생하더라도 그 기능적 관계가 분리되어 있도록 해야 한다.

리눅스 커널의 많은 드라이버 생명주기 이벤트들이 옵져버 패턴으로 이루어져 있다. 각 드라이버들을 병렬적으로 만들지만 각 드라이버들의 상호 관계를 포함하지는 못한다. 따라서 드라이버 생명주기 콜백들의 실행 순서 오류로 인해 문제가 발생하는 경우가 있다.

systemd 의 부팅 순서도 비슷한 경우의 병렬 실행을 실시한다. 하지만 각 서비스간의 연결관계를 별도로 표시할수 있어 트리구조의 부팅 시퀀스 그래프를 제공한다.

주체의 변경이 심화될때 감시자의 호출의 양이 배수로 증가하는 단점이 있다.

notify 를 호출하는 주체는 달라질수 있다. 책에서는 기본적으로 감시자 자체에서 호출하도록 되어 있다. 호출과 수신의 기능이 감시자 내부에서 잘 분리되어 있지 않다면, 순환참조의 복잡성에 빠질 수 있다.

update 데이터의 양에 따라 push / pull 모델을 사용 할 수 있다.

중재자 패턴을 이용하여 주체와 감시자 사이에 ChangeManager 를 둘 수 있다. 둘 사이의 관계가 복잡해 질수록 유용하다.

가장 많이 사용하고 있었지만 잘 모르고 있었고, 잘못 사용하고 있었다.

### 상태 패턴
옵져버 보다 더 오랫동안 사용해온, 가장 좋아하는 패턴 하지만 사용방법이 이렇게 다를 줄은 몰랐다.

상태에 따른 연산의 변화가 코드 전반에 분산하여 사용했다면, 책에서는 한가지 상태와 관련된 모든 면산을 하나의 객체에 집중하게 하였다.

책의 방법이 상태에 대해서 집중할 수 있는 더 좋은 방법이겠지만, 기능이 거대하여 상태 내부에 집중하기 어려울 때에는 더 어려운 방법일 수 있다.

최근의 코딩에서는 가능한 상태 정의와 행동이 최대한 집중될 수 있게 하였지만 모든 기능을 포함 한것은 아니다.

상태 관련 연산의 집중에 대해서는 책과 달리 더 유연하게 대처할 필요가 있다.

또한 상태 전이와 상태 전이에 따른 행동을 구분해서 코딩할 경우 기능의 단계를 더 구분할 수 있어 좋아진 경우도 있었다.

기능의 단계를 나누는 것은 전략 패턴과 유사하지만 객체지향만으로는 설명하기 어렵고, 도메인의 해석과 중요도에 따라서 나누는 것을 생각해야 한다.

### 전략 패턴
플라이급 패턴을 사용하면 좋다. 즉, 상태값 저장없는 함수, js 의 static 함수로 구성하는 것이 좋다. 항상 그렇지만 static 이 아닌 함수는 최소화 해야한다.

context 를 stratage 객체에 전달하는 방법은 둘 사이의 결합도를 높게 만든다. 따라서 매개변수만 stratage 객체에 전달하는 것이 맞다. 플라이급 패턴이 필요하다.

JS 와 같은 스크립트 언어의 장점은 선언과 기능 변경에 런타임과 컴파일 시점의 차이가 없어 쉽게 진행할 수 있다는 것이다.

### 탬플릿 메서드 패턴
서브 클래스가 부모 클래스의 연산을 제대로 호출 안할 수도 있다. 따라서 연산을 부모 클래스로 옮기고 서브 클래스의 연산을 호출하는 식으로 구현하는 것이 낫다.

객체 지향의 기본 구현 방식이기 때문에 사용하고 안하고를 고민할 필요가 없다. 하지만 덧붙여서 도메인 중요 단계에 따라 구현을 구분하는 것은 중요하다.

추상 클래스에서 바로 구체 클래스로 가는 것이 아니라 탬플릿 메서드를 통한 중간 구현 단계를 두는 것이 좋다.

전략 패턴을 추가할 수 있을 뿐만 아니라 핵심 도메인을 더 쉽게 알아 볼 수 있게 만들 수 있다.
